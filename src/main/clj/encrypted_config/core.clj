(ns encrypted-config.core
  (:require [buddy.core.crypto :as crypto]
            [buddy.core.codecs :as codecs]
            [buddy.core.nonce :as nonce]
            [buddy.core.hash :as hash]
            [crypto.random :as ctr])
  (:gen-class))

(defn- hash-sha256
  [secret-text]
  (hash/sha256 secret-text))

;; TODO: don't use salt-key but instead use random-hex to generate salt-key
(defn- complex-encrypted
  [input-text secret-text salt-key]
  (let [encrypted-key (hash-sha256 secret-text)]
    (crypto/encrypt (codecs/to-bytes input-text)
                    encrypted-key
                    salt-key
                    {:algorithm :aes128-cbc-hmac-sha256})))

(defn encrypted-to-hex
  [input-text secret salt-key]
  (codecs/bytes->hex (complex-encrypted input-text secret salt-key)))

(defn encrypted-wrapper
  "Take the input that has been encrypted with a given secret key"
  [hex-input]
  (codecs/hex->bytes hex-input))

(defn decrypted-wrapper
  "Decrypt the given input (hex) using a given secret key.
  salt-key should be generated by =(nonce/random-bytes 16)="
  [hex-input secret-key salt-key]
  (->
   (crypto/decrypt
    (encrypted-wrapper hex-input)
    (hash-sha256 secret-key)
    salt-key
    {:algorithm :aes128-cbc-hmac-sha256})
   (codecs/bytes->str)))

(defn str->encrypted
  "Encrypted the given `input-text' using a given `secret-key'.
  You must write down the random-hex string generated with this routine."
  [input-text
   secret-key]
  (let [random-hex (ctr/hex 16) ;; Need to store this one!
        salt-key (codecs/hex->bytes random-hex)
        encrypted-text (encrypted-to-hex input-text secret-key salt-key)]
    (do
      (println (str "FYI: input-text*     :" input-text))
      (println (str "FYI: secret-key*     :" secret-key))
      (println (str "FYI: random-hex*     :" random-hex))
      (println (str "FYI: encrypted-text* :" encrypted-text))
      ;; Return the encrypted string
      encrypted-text)))

(defn str->decrypted
  "Decrypted previously encrypted text using secret-key and random-hex."
  [encrypted-text
   secret-key
   random-hex]
  (let [salt-key (codecs/hex->bytes random-hex)]
    (do
      (println (str "FYI: encrypted-text* : " encrypted-text))
      (println (str "FYI: secret-key*     : " secret-key))
      (println (str "FYI: random-hex*     : " random-hex))
      (println (str "FYI: encrypted-str*  : " encrypted-text))
      ;; Return the decrypted string
      (decrypted-wrapper encrypted-text secret-key salt-key))))

(defn -main [& args]
  ;; (let [{:keys [options arguments errors summary]}
  ;;       (cli/parse-opts args opt/options)]
  ;;   (cond
  ;;     (:help options)
  ;;     (exit 0 (usage summary))
  ;;     (:config options)
  ;;     (create-new-repo! options)))
  ;; -------------------------------------------- ;;
  (try
    ;; Note: running this multiple time will give different result as =random-hex= is re-generated each time.
    (str->encrypted "MyP@ssword!"
                    "MySec$tKey@")
    ;; =>
    ;;FYI: input-text*     : MyP@ssword!
    ;;FYI: secret-key*     : MySec$tKey@
    ;;FYI: random-hex*     : 74da4feae9c06f49f4840a6d610bd3ee
    ;;FYI: encrypted-text* : 19130b61026ff358b4a3db02334d87c3afaf3da9282e2d6bb90a158df7d0d07f

    ;; Now we try to decrypt this string
    (str->decrypted "19130b61026ff358b4a3db02334d87c3afaf3da9282e2d6bb90a158df7d0d07f"
                    "MySec$tKey@"
                    "74da4feae9c06f49f4840a6d610bd3ee") ;;=> "MyP@ssword!"
    (catch Exception e
      (.printStackTrace e)
      (println (str "Unexpected errors: " (.getMessage e))))))
